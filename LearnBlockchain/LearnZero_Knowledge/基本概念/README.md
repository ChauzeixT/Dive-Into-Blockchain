# 零知识证明基本概念

> 前言：零知识之前的历史，[Mental Poker[SRA81]](https://people.csail.mit.edu/rivest/pubs/SRA81.pdf)（可以论证，不能证明）
>
> > 论证：利用论据（原因，例子，数据等），验证或支撑论点为真（无限接近100%）
> >
> > 证明：从空条件集合出发，利用假设法、公理、公设，来证明一个命题的恒为真，每个过程都要详细，确信的100%

<div align=center>
<img src="https://github.com/DessertHeart/Dive-Into-Blockchain/assets/93460127/0c0401f8-31b6-4310-b7eb-97dfae251532" style="width:65%;">
</div>

**定义**：零知识证明（ZKP, Zero-Knowledge Proof）是**一方（证明者Prover）向另一方（检验者Verifier）证明某命题的方法**。零知识协议是一种协议，它允许你证明你知道一些特定的数学事实，而无需透露有关事实本身的任何信息。在零知识协议中生成的证明称为零知识证明。

- 零知识：Prover 的回答不会泄露其具体信息，验证者除了正确外，不知道任何其他信息；

- 完备性：如果 Prover 知道正确的具体信息，他们总是能够做出令人满意的回答；

- 可靠性：如果 Prover 不知道正确的具体信息，他们最终会被抓住。

  > 知识可靠性：是可靠性的更强要求，认为如果Prover实际不知道该“知识”，也一定会失败（该点往往是使用者实现，比如有的ZK-Snark系统本身只能是实现可靠性，因为系统内不包含“知识”信息，开发者在该系统上架构，可以实现知识可靠性）

**应用**：零知识证明都是针对**可计算问题**

> 对于一个判定问题，若存在一个总是在有限步内停机且能够正确进行判定的图灵机，则这个问题是一个 **图灵可计算** 的问题，否则这个问题是一个 **图灵不可计算** 的问题。

> 典型不可计算问题-停机问题：给定 $α$ 和 $x$ ，判定 $M_α$ 在输入为 $x$ 时是否会在有限步内停机。



**古典ZK与现代ZK的区别：**

在**古典ZK**中，对于像[三色图问题](https://www.jianshu.com/p/7b772e5cdaef)，研究人员（数学家）都必须提出一个应用于特定场合的特殊用途/特定的ZK协议；

1. 而在**现代ZK**中，我们需要并且实现的是一个**通用框架**完成所有可计算问题。

   > 一个输出 $y$ ，一个任意函数 $f$，知道一个秘密 $x$ ，使得 $f(x)=y$

   在此基础上，我们能够在完全隐私的情况下验证任意计算（如货币、数字所有权的转移）。也是因此，程序员才可以上手写逻辑。

2. 除了我知道他正确之外的信息，别的我都不知道

   即：**完美零知识证明**，如果 “[模拟](https://sammyne.github.io/zkp/02-simulation/#%E5%8C%BA%E5%88%86%E4%B8%A4%E4%B8%AA%E4%B8%96%E7%95%8C)视图” 和 “真实交互” 在计算上无法区分，则为完美零知识(例如：在现代中，公私钥对不叫零知识证明，因为不是完美)

